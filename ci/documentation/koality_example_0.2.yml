--- #Koality: 0.2

# All configuration is done in a koality.yml or .koality.yml file placed in the root directory of your repository.
# Yaml is human readable format that represents JSON (dictionaries)
# The following is an example configuration file from one of the repositories for the Koality product itself.

# The first section is the language definition. Define which languages your project uses and what version is needed.
languages:
  python: 2.7
  ruby: 1.9.3
  nodejs: 0.8.12

# The setup section allows you to define and describe your production environment. We use it to exactly replicate 
# prod so your tests mirror that of production.
setup:
  # The packages section defines dependencies your project needs.
  - packages:
    # Define system packages dependencies here. These packages are installed through apt.
    - system:
      - zlib1g
      - gcc
      - g++
      - curl
      - libevent-dev
    # Here's an example of language specific dependencies. Pip is utilized for python
    # You can define versions of packages or just grab the default pip package.
    # For python, you can also define a requirements.txt file.
    - pip:
      - pika: 0.9.5
      - pycrypto: 2.6
      - psycopg2
      - requests
      - install requirements: platform/requirements.txt

    # This example is for nodejs. Npm is used to resolve packages.
    - npm:
      # Packages defined directly under npm are install globally
      - iced-coffee-script
      - testacular
      # If a directory section is defined, "npm install" is run from that directory, installing all dependencies under package.json
      - npm install: web/back
  # Defines databases used in a production environment. Databases for tests are local to a particular VM running tests.
  # Currently, only postgres and mysql are supported
  - databases:
    # an example postgres configuration
    - postgres:
      - name: koality
        username: lt3
    # an example mysql configuration
    - mysql:
      - name: koality
        username: lt3
  # Arbitrary scripts can be run at any point in time to do specific configuration and provisioning of the box not handled
  # by our default sections. In this example, a .gitconfig is being created as part of provisioning and rabbitmq is started.
  - scripts:
    # Each of these lines is run as if it was typed into a shell.
    - scripts/post-setup.sh
    # When "directory" section is defined, the following command under "script" is run in that directory.
    - path: scripts
      script: ./rabbitmq_setup.sh

# The following sections are relevant to the building and testing of your code.

# Any script definitions under compile are run pre-testing. These can be used to build your code, create artifacts,
# or run static analysis checks.
compile:
  scripts:
    # Each section under compile can be given an arbitrary name, which will appear in the web ui. We've named the following
    # sections install_platform, compile_webserver, compile_website, but these names can be arbitrary. The script that is run
    # must return an error code. If it returns 0, we assume it ran successfully. Any other code means that this build has failed, and
    # we will prevent the code from merging and notify the committer.
    - python setup.py install:
        path: platform
    - compile webserver:
        path: web/back
        script: ./compile.sh
    - compile website:
        path: web/front
        script: ./compile.sh
# The test section is modeled after the compile section, but has the additional "machines" and "factories" sections.
test:
  # The number of VMs to create to run tests on
  machines: 2
  # Each script in the test section can be run in parallel with others across multiple virtual machines
  scripts:
    - platform unit tests:
        path: platform
        script:
          - nosetests -sv tests/unit_tests
        timeout: 3
    # If a "script" key is not provided, the command name is run.
    # The default path is the root of the repository, and the default timeout is 600 seconds
    - npm test
  # Factory scripts that will output test scripts sections to be run in parallel. These should be ouptutted to stdout in yaml in the same format as each above test section
  factories:
    - integration test factory:
        path: platform
        # The following is an example factory which prints out a nosetests command for each .py file in the platform/tests/integration_tests directory
        script:
          - |
            ls tests/integration_tests/*.py | while read test; do
              echo "- $test:"
              echo "    script: nosetests -sv $test"
              echo "    path: platform"
            done

